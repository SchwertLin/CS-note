# 进程

[TOC]



## 定义

早期的计算机只支持单道程序。在引入多道程序技术后：内存中程序段以及数据段不再有固定的地址。此时OS要如何找到各程序的存放位置？系统为每个运行的程序配置一个数据结构，称为PCB（process control block 进程控制块，也称为进程表），用来描述进程的各种信息。

为了方便OS的管理，因此引入了进程以及进程实体的概念。

**进程的创建**：有四种主要事件会导致进程的创建。

>1. 系统初始化
>2. 正在运行的程序执行了创建进程的系统调用
>3. 用户请求创建一个新进程
>4. 一个批处理作业的初始化



**进程的终止**：迟早会被终止

> 1. 正常退出（自愿）
> 2. 出错退出（自愿）
> 3. 严重错误（非自愿）
> 4. 被其他进程杀死（非自愿）



**进程实体**：由程序段、数据段、PCB三部分构成。也称为进程映像。

> 一般情况下，我们把进程实体称为进程。
>
> 创建进程 = 创建进程实体中的PCB
>
> 撤销进程 = 撤销进程实体中的PCB
>
> ==PCB是进程存在的唯一标志==



**进程**：是程序的一次执行过程，是一个程序及其数据在处理机上顺序执行时所发生的活动，是具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位。

同时：==进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。==

>事实上，进程实体与进程并不一样。
>
>进程实体是静态的、进程是动态的。



**进程的层次结构**：父进程以及子进程

> UNIX：整个系统中，所有的进程都属于以`init`为根的一棵树。进程不能剥夺其子进程的“继承权”。
>
> Windows：没有进程层次的概念，所有进程地位相同。唯一类似进程层次的暗示：在创建进程的时候，父进程得到句柄可以控制子进程。但是句柄可以被传送给其他的进程。



### 组成

由程序段、数据段、PCB三部分构成。

>1. PCB:包含OS对其进行管理所需的各种信息。
>2. 程序段：存放程序代码。
>3. 数据段：程序运行时使用、产生的运算数据。

> PCB：
>
> 1. 进程描述信息：进程标识符PID（唯一不重复 ，用以区别不同的进程）、用户标识符UID（标识所属的用户是谁）
> 2. 进程控制和管理信息：进程当前状态、进程优先级
> 3. 资源分配清单：程序段指针、数据段指针、键盘、鼠标
> 4. 处理机相关信息：各种寄存器值【】‘进程切换时需要把进程当前的运行记录下来保存到PCB之中）

> or:
>
> 1. 进程管理
> 2. 存储管理
> 3. 文件管理



### 组织

==区分==：进程的组成是**一个进程内部由哪些部分构成的问题**，而进程的组织讨论的是**多个进程之间的组织方式的问题。**

分为两种方式：链接方式以及索引方式。

>1. 链接方式：按照进程状态将PCB分为多个队列，OS将持有指向**各个队列的指针。**（链表方式存放进程）
>
>2. 索引方式：根据进程状态的不同，建立几张索引表，OS将持有指向**各个索引表的指针。**（索引表存放进程）



### 特征

==动态性是进程最基本的特征。==

1. ==动态性==：动态地产生、变化、消亡。
2. 并发性：内存中有多个进程实体，各进程可并发执行。
3. 独立性：独立运行，能独立获得资源，独立接受调度的基本单位。
4. 异步性：各进程按各自独立的、不可预知的速度向前推进，OS要提供“进程同步机制”来解决异步问题。
5. 结构性：每个进程都会配置一个PCB。由程序段、数据段、PCB三部分构成。



**考察**：PCB内会存放哪些数据？

---包含OS对其进行管理所需的各种信息。







### 状态

为了方便对于进程的管理，将进程合理划分为以下三个基本状态。

>1. 运行态：此时占有CPU资源，并在CPU上运行。
>2. 就绪态：已经具备运行条件，但是此时并没有空闲的CPU。（拥有除了处理机之外的所有资源）
>3. 阻塞态（等待态）：在等待某一时间而暂时不能运行。

==注意：单核处理机下：每一时刻最多只有一个进程处于运行状态。双核下是两个（进程）==

为了提高CPU的利用率：要先将其他所需要的资源全部准备到位后，进入就绪态，等待CPU。

还有另外两种状态：

> 1. 创建态（新建态）：初始化工作。（初始化分配资源、PCB）
> 2. 终止态（结束态）：完成撤销进程相关的工作，完成将分配的资源回收工作，撤销PCB。





#### 进程状态的转换

![](C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220117112050.png)





## 进程控制

#### **什么是进程控制？**

进程控制的主要功能是对系统中的所用进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

（人话：实现进程状态转换）

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213105553.png" style="zoom: 80%;" />

==注意：==在进入运行态后，对于该进程可能会再次进入就绪态（也就是就绪队列），或者是**依据等待事件**进入阻塞态。

进程的状态切换是比较麻烦的。有时为了防止PCB与状态改变造成不匹配的问题↓



#### **如何实现进程控制？**

使用原语来实现进程控制。对原语：采用“关中断指令”和“开中断指令”实现。

【关中断指令--原语代码--开中断指令--其他代码--···】

> 原语的特点：执行期间不允许中断，只能一气呵成。
>
> 原子操作：不可被中断的操作。

==关 / 开中断指令权限十分大，只允许在核心态下执行的特权指令==

若是拿到用户态下指令：会导致用户态永不中断，十分危险。



#### **进程相关的原语**

进程控制会导致进程状态的转换。无论是何原语：

>1. 更新PCB中的信息
>
>   a. 所有的进程控制原语一定会修改进程状态标志
>
>   b. 剥夺当前运行进程的CPU使用权必须保存其运行环境
>
>   c. 某进程开始运行前必然要恢复其运行环境
>
>2. 将PCB插入合适的队列
>
>3. 分配 / 回收资源

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213111149.png" style="zoom:80%;" />

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213111505.png" style="zoom:80%;" />

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213111510.png" style="zoom:80%;" />

==进程的唤醒与阻塞必须是由于同一事件，因此阻塞原语&唤醒原语必须成对使用。==

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213111629.png" style="zoom:80%;" />





## 进程通信

进程通信：进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。

==各进程之间的地址空间非共用。==(但是有时候进程之间的信息交换又是必须实现的。为了保证进程之间的安全通信，OS会提供一些方法)

以下三种方式均为实现进程之间的信息交换。

#### 共享存储

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213112700.png" style="zoom:80%;" />

相对而言：基于数据结构的共享是OS来决定的。该区域内只能存放某一类型的数据结构（只能存放一种喔）而且大小也有限制。

基于存储区的共享是由相互通信的两个进程相互决定的（不关OS的事）。他俩自个儿决定到底存放什么，所以比较自由呢。





#### 消息传递

进程间的数据交换以格式化的消息为单位，进程通过OS提供的“发送消息 / 接收消息”两个原语进行数据交换。

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213114040.png" style="zoom:80%;" />

【间接通信中】进程：接受原语 / 发送原语



#### 管道通信

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213113453.png" style="zoom:80%;" />

==重点==：是一个管道只能实现半双工通信。写满时不能再写；读空时不能再读。未写满不能读；未读空不能写。









# 线程

## 定义

线程产生的原因：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：

> 1、进程在同一时间只能干一件事
>
> 2、进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。

因此，操作系统引入了比进程力度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。和进程相比，线程的优势如下：

> 1、从资源上来讲：线程是一种非常"节俭"的多任务操作方式。在linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。
>
> 2、从切换效率上来讲：运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。
>
> 3、从通信机制上来讲：线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。

将同一个进程分为不同的线程。引入线程后，线程成为程序执行流的最小单位。

==可以将线程理解为--轻量级进程==



### 作用

引入线程后：不仅进程之间可以并发，进程内的各线程之间也可以并发。

从而进一步提高了系统的并发度，使得一个进程内可以并发处理各种任务。

引入线程后：==进程==只作为除CPU之外的系统资源的分配单元。

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213115320.png" style="zoom:80%;" />

### 属性

==重点==:线程是处理机调度的单位、进程是资源分配的单位。

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213115513.png" style="zoom:80%;" />



### 实现方式

**用户级线程**（User Level Thread, ULT）由应用程序通过线程库来实现。所有的线程管理工作都由应用程序负责。

在ULT中，线程切换可以在用户态下即可完成，无需OS干预。

对用户来说：有多个线程。但是OS内核看来，并不能意识到线程的存在。（ULT对用户不透明，对OS透明）

这里的透明指的是能否意识到这个东西存在。



**内核级线程**（Kernel Level Thread, KLT）又称内核支持的线程。其管理工作由OS内核完成。线程调度、切换等工作都有内核负责，因此需要在核心态下才能完成。（是从OS内核视角才能看到的线程）

==内核级线程才是处理机分配的单位==



在同时支持ULT与KLT的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上。==（$n\ge m$）==

==重点==：ULT对用户可视、KLT对OS可视。因此KLT才是处理机分配的单位。





### 多线程模型

在同时支持ULT和KLT的系统中，由几个ULT映射到几个KLT的问题将引起”多线程模型“问题。

**多对一模型**

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213121239.png" style="zoom:80%;" />



**一对一模型**

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213121349.png" style="zoom:80%;" />

**多对多模型**

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213121448.png" style="zoom:80%;" />

#### 调度程序激活机制

虽然捏，内核级线程在一些关键点上优于用户级线程，但是KLT的速度太慢了。调度程序激活机制：保持其优良特性的前提下改进其速度。避免在用户空间以及内核空间之间不必要的转换。

工作目标：模拟内核线程的功能。

上行调用：内核了解一个线程被阻塞之后，内核会通知该进程的运行系统，并且在堆栈中以参数形式传递有问题的线程编号和所发生的事件的一种描述。内核通过在一个已知的起始地址启动运行时系统，从而发出通知。



## 处理机调度

### 概念

（感觉是排序捏）

当有一堆任务要处理，但是由于资源有限，这些事情没办法同时处理，这时需要确定某种规则来确定这些任务的顺序。这就是“调度”研究的问题。

==在多道程序系统中==，进程的数量往往是多于处理机个数的，这样不可能同时并行地处理各个进程。

**处理机调度**：从就绪队列中按照一定地算法（调度算法）选择一个进程并将处理机分配给它运行，以实现进程的并发执行。





### 层次

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此需要确定某种规则来决定将作业调入内存的顺序。

#### 高级调度（作业调度）

按照一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业。给他们分配内存等必要资源，==并建立相应的进程（建立PCB），以使他们获得竞争处理机的权利。==



高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。==作业调入时会创建相应的PCB，作业钓出时才撤销PCB。==**高级调度主要是指调入的问题**，因为只有调入的时机需要OS确定，但是调出的时机必然是作业运行结束后才调出。





#### 中级调度（内存调度）

引入了虚拟存储技术之后，可以将暂时不能运行的进程调至外存进行等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。可以==提高内存利用率和系统吞吐量。==



**挂起状态**：暂时调到外存等待的进程状态。

值得注意：PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息。OS通过内存中的PCB来保持对各个进程的监控、管理。被挂起的PCB会被放到挂起队列中。



**中级调度**（内存调度）：决定将哪个处于挂起状态的进程重新调入内存。

==一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度高。==



>**进程的挂起态与七状态模型**
>
>挂起状态：暂时调到外存等待的进程状态。
>
>挂起态又可以进一步细分为**就绪挂起、阻塞挂起**两种状态。
>
>原有的五状态→七状态

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213165443.png" style="zoom:80%;" />



#### 低级调度（进程调度）

主要任务：按照某种方法和策略（算法）从就绪队列中选取一个进程，将处理机分配给它。

低级调度是OS中最基本的一种调度，在一般OS中都必须配置。

频率很高，10ms+/次

##### 时机

**何时需要进行进程调度？**

① 当前运行的进程主动放弃处理机（进程正常终止、==运行过程中发生异常终止==、进程主动请求阻塞）

② 当前运行的进程被动放弃处理机（分配的时间片用完、有更紧急\更高优先级的进程处理）

**何时不能进行进程调度与切换？**

① 在处理中断的过程中。（主要是因为中断处理过程复杂，与硬件相关，很难在此过程中做到进程切换）

② 进程在操作系统内核程序临界区中。

③ 在原子操作过程中(原语)。原子操作不可中断。



>√  进程在操作系统内程序临界区中不能进行调度与切换。
>
>×  进程处于临界区时不能进行处理机调度。

**临界资源**：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源。

**临界区**：指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又具有无法同时被多个线程访问的特性。（也就是指访问临界资源的程序片段）

**内核程序临界区**：用以访问某种内核数据结构。（如各就绪进程的PCB组成）

进程访问之前会先“上锁”，如果在没退出临界区之前就进行进程调度（需要访问就绪队列），但是此时的就绪队列被锁住了，因此无法进行进程调度。

==似乎有一些难以理解（maybe）==

> 解释：比如现在有一个进程需要使用打印机的资源，然后就会给它(打印机)上锁。在打印机完成打印之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备。就会导致一个问题：==此时一直不允许进程调度的话，CPU就会一直空闲（浪费）==
>
> 普通临界区访问的临界资源并不会直接影响操作系统内核的管理工作。这样就可以随时进行调度和切换。



##### 方式

分为非剥夺调度方式及剥夺调度方式。

>**非剥夺调度方式（非抢占方式）**：只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机。直到该进程终止或是主动要求进入阻塞态。==无法处理紧急任务==
>
>**剥夺调度方式（抢占方式）**：当一个进程正在处理机上执行时，如果有一个更重要的进程到达，则立即暂停正在执行的进程，讲过处理机分配给那个进程。

>进程の切换：
>
>**狭义の进程调度**：从就绪队列中选中一个要运行的进程。
>
>**广义の进程切换**：包含了选择一个进程以及进程切换两个步骤。
>
>**进程切换：**指一个进程让出处理机，由另一个进程占用处理机的过程。

> 进程切换の过程：
>
> ① 对原来运行进程各种数据的保存。（保存到PCB中）
>
> ② 对新的进程各种数据的恢复。（从PCB中读取，然后保存到寄存器中）
>
> ==进程的切换也不能太过频繁，耗时间==





#### 对比

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220213165742.png" style="zoom:80%;" />

![](C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220224161250.png)





## 调度算法

### 评价指标

1. CPU利用率：

   ==$利用率=\frac{忙碌的时间}{总时间}$==

2. 系统吞吐量

   ==$系统吞吐量=\frac{总共完成作业数}{总花费时间}$==

3. 周转时间

   指从作业被提交给系统时，到作业完成为止的这段时间间隔。

   包括四段时间：①作业在外存后备队列上等待作业调度的时间②进程在就绪队列上等待进程调度的时间③进程在CPU上执行的时间④进程等待 I\O 操作完成的时间。（后三项是就绪态、运行态、阻塞态，可以在一个作业的处理过程中发生多次）

   ==$作业周转时间 = 作业完成时间 - 作业提交时间$==

   ==$平均周转时间=\frac{各作业周转时间之和}{作业数}$==

   ==$带权周转时间=\frac {作业周转时间}{作业实际运行时间}$==   带权周转时间 ↓ ， 用户满意度 ↑ 。

4. 等待时间

   指作业/进程处于等待处理机状态时间之和。显然需要越少的等待时间越好。

   > 等待 I/O 完成的期间其实进程也被服务，因此不计入等待时间。
   >
   > 对于作业：不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。

5. 响应时间

​		指用户提交请求到首次产生想要所用的时间。



### 算法

#### 先来先服务（FCFS）

按照作业/进程到达的先后顺序进行服务。（非抢占式）

>用于作业调度时：考虑哪个作业先到达后备队列。
>
>用于进程调度时：考虑哪个进程先到达就绪队列。

>有利于长作业、不利于排在长作业后面的短作业。

#### 短作业优先（SJF）

最短的作业/进程优先得到服务。

> 追求最少的平均等待时间、最少的平均周转时间、最少的平均带权周转时间
>
> 可用于作业调度、进程调度（短进程优先）。

> SJF和SPF是非抢占式算法。但是也有抢占式的版本——最短剩余时间优先算法（SRTN，Shortest Remaining Time Next）。

> 对短作业有利，对长作业不利。可能对长作业产生饥饿现象。

==若题中未特别说明，提到的“短作业/进程优先算法”默认是非抢占式的。==

==×   SJF调度算法地平均等待时间、平均周转时间最少。==

==√  **在所有进程同时可运行时**，SJF调度算法地平均等待时间、平均周转时间最少。==

> 为啥要加这么一句话？



由于SJF/SPF较为简单，在此不再赘述。以下例题是采用SRTN完成。

![](C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220224203358.png)

> (其实也不难，主要是在这种情况下，进程可能断断续续地执行，计算照常就是)





#### 高响应比优先（HRRN）

综合考虑作业/进程地等待时间和要求服务的时间。(非抢占式)

在每次调度时先计算各个作业/进程的响应比，选择==响应比最高==的作业/进程为其服务。

==$响应比=\frac{等待时间+要求服务时间}{要求服务时间}$==     （响应比 $\ge$ 1）

>【相当于折中处理FCFS与SJF】
>
>等待时间相同时：要求服务时间短的优先（SJF）
>
>要求服务时间相同时，等待时间长的优先（FCFS）
>
>对于长作业：等待时间 ↑ ，其响应比会 ↑ ，从而避免长作业饥饿的问题。



**总结**

以上的算法只关心一些评价系统整体性能的指标，并不关心“响应时间”，也不区分任务的紧急程度什么的。
因此对用户来说，交互性体验极差。一般适用于早期的批处理系统。



#### 时间片轮转调度算法（RR）

公平地、轮流为各个进程服务。让每个进程都可以在一定时间间隔内响应。（一般用于进程调度）（抢占式）（适于分时OS）

规则：按照各个进程到达就绪队列得顺序，轮流让各个进程执行一个时间片（100ms类似）若进程未在一个时间片内执行完毕，就会被剥夺处理机，将进程重新放入就绪队列重新排队。

==在计算的时候，一般默认新到达的进程先进入就绪队列，然后上一个时间片执行完的进程再进入队列中。==

缺点：如果时间片太大，就会退化为先来先服务调度算法，并且增大进程响应时间。因此时间片不能太大；同时，要是时间片太小，系统会消耗大量的时间来进行进程切换，从而导致实际用于进程执行的时间比减少。**设计时间片让切换进程开销不超过1%**。





#### 优先级调度算法

每个任务（进程、线程）都有自己的优先级，调度时选择优先级最高的任务执行。利于处理紧急任务。（适用于实时OS）（非、抢占式均有）(会发生饥饿)

> 这个优先级的就绪队列，好像优先队列喔。

>合理设置进程的优先级：
>
>1. 系统进程 > 用户进程
>2. 前台进程 > 后台进程
>3. I / O型进程 > 计算型进程



#### 多级反馈队列调度算法

是对其他调度算法的折中权衡。（用于进程调度）（抢占式）（会导致饥饿）

> 1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
>
> 2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下- -级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾
>
> 3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片
>
>    
>
>    在k级队列的进程运行过程中，若更上级的队列（1~k-1级）户中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。



**总结**：交互式OS（如分时OS、实时OS）更注重系统的响应时间、公平性、平衡性等指标。所以以上三种算法适用于交互式OS



## 进程间通信

### 进程同步

进程具有异步性。所以进程同步主要解决的是进程的异步问题。

同步需要制约协调进程之间的工作次序。



### 进程互斥

进程的并发需要共享的支持。

资源共享：互斥共享（一个时间段只允许一个进程访问）、同时共享（宏观上允许多个进程访问）。

进程互斥：当一个进程访问某临界资源时，另一个也想访问临界资源的进程必须等待。当目前正在访问临界资源的进程结束后释放了资源，另一个才能访问该临界资源。

```c++
do{//一般分为四个Part
    entry section;//进入区（上锁）
    critical section;//临界区（访问）
    exit section;//退出区（解锁）
    remainder section;//剩余区（其他处理）
}while(true)
```

> 关键区、临界区（critical region）：以互斥的方式完成。此时最多只有一个进程在内。
>
> 进程进行完毕，出去后（或是部分在外面），都不能阻止其他进程进入关键区。
>
> 当一个进程进入关键区，就会“加锁”，防止其他进程进入关键区。



#### 软件层面

**解决方案**：忙等待（Busy Waiting）

事实上效率比较低：在所属的时间片时，可能一直在忙等待。忙等待：此时一直在等待，但是没法推进，还占用着处理机。此时没法为其他的进程提供服务。

```c++
//------------------------------------【严格轮换法】
while(true){//进程0
    while(turn!=0);//loop:进程1 2 都可修改turn变量，但修改是原子操作
    critical_region();
    turn=1;
    noncritical_region();
}
while(true){//进程1
    while(turn!=1);//loop
    critical_refion();
    turn=0;
    noncritical_region();
}
//以上存在的问题就是：只能交替进行，某进程不能一下子执行两次
//以上这种只适用于两个进程相当速度比较平均时执行。
//-------------------------------改进【Peterson解法】
#define FALSE 0
#define TRUE  1
#define N     2                      //进程的数量

int turn;                            //轮到谁了
int interested[N];                   //初始值为0/False
void enter_region(int process){      //进程不是1就是0
     int other;                      //未进行的那个进程是？
     other = 1 - process;            //知道这个没进行的进程是哪个
     interested[process] = true;     //感兴趣：谁想进这个关键区呢？
     turn = process;                 //设置一个flag，估计是为了防止多线程时同时进行
     while (turn == process && interested[other] == true);//双判断优化
}
void leave_region(int process){      //执行结束
     interested[process] = false;    //如果没出来就一直是true，锁死关键区
}
//有效的防止了只能交替进行的情况，较快的进程可以持续进行。
//在多线程中，可能两进程相互交替进行enter_region()中的语句，但是速度更快执行的先进入关键区。
//但是我的疑问是：比如先进行的修改了turn=process；在这个先进行的进程在进行while语句之前，后面的进程也进行了turn=process，此时应该是后面这个进程先进行。
```

>  将两进程推广为多进程？如何做？---布吉岛



#### 硬件层面

①中断屏蔽方法：原子操作。

> 实现关中断后不允许当前进程被中断、就不会发生进程切换，直至开中断。(这两个权限太高了)

> 适用内核进程、但是不适用于多处理机、用户进程。



②特殊指令：TSL

（硬件层面）执行TSL将总线锁住,防止其他CPU在本指令结束前访问内存。使得某些读写操作成为原子操作的。

```c++
enter_region://
        TSL REGISTER,LOCK       //读取Lock的值,把读到的值存入寄存器RX中,然后给LOCK设置一个非0的值（设置到LOCK对应的内存中）
        CMP REGISTER,#0         //比较内存器的值是不是0
        JNE ENTER_REGION        //判断结果是不是0:如果是0,Lock=1,进入临界区；如果是1，那么循环等待（已有进程在关键区,这些步骤都已走过）
        RET                     //返回调用者，进入临界区

leave_region:
       MOVE LOCK,#0             //在锁中存入0
       RET                      //返回调用者

//保证只有一个进程可以抢到进入关键区。如果多个进程同时调用TSL，利用TSL的特性：只有一个进程访问，其他的会被block
//但是也存在一定问题：当某进程想要进入关键区，但是可能始终抢不到锁，并不能保证所有进程都能进入关键区
```

③XCHG解法：Swap指令（硬件实现、原子操作）类似TSL指令。



### 睡眠与唤醒

Peterson解法和TSL或XCHG解法都是正确的，但它们都有忙等待的缺点。这些解法在本质上是这样的： 当一个进程想进入临界区时，先检查是否允许进入，若不允许，则该进程将原地等待，直到允许为止。

这种方法不仅浪费了CPU时间，而且还可能引起预想不到的结果。考虑一台计算机有两个进程，H优先级较高，L优先级较低。调度规则规定，只要H处于就绪态它就可以运行。在某一时刻，L处于临界区中，此时H变到就绪态，准备运行（例如，一条I/O操作结束）。现在H开始忙等待，但由于当H就绪时L不会被调 度，也就无法离开临界区，所以H将永远忙等待下去。这种情况有时被称作优先级反转问题。

现在来考察几条进程间通信原语，==它们在无法进入临界区时将阻塞，而不是忙等待==。最简单的是sleep和wakeup。sleep是一个将引起调用进程阻塞的系统调用，即被挂起，直到另外一个进程将其唤醒。wakeup 调用有一个参数，即要被唤醒的进程。另一种方法是让sleep和wakeup各有一个参数，即有一个用于匹配sleep和wakeup的内存地址。



主要是维护同步互斥，维护共享buffer。

有界缓存区/无界缓存区：有界存在的问题就是buffer可能被塞满。



### 信号量

不需要忙等待的同步工具。

两个原子操作：

P操作：enter region → 把等待的进程放入等待操作。

V操作：leave region → 把挂在信号量的等待进程中头进程取出来进行。
