# 复习题

 单选题 (1分)

(2012统考)下列选项中，不可能在用户态发生的是（ ）

A 系统调用

B 外部中断

C 进程切换

D 缺页



> 系统调用是提供给应用程序使用的，由用户态发出，进入内核态执行。【重点是由用户态发出】
>
> 外部中断随时可能发生；【来源于外设】
>
> 应用程序执行时可能发生缺页；【异常服务例程会发生缺页，可嵌套两个异常】
>
> 进程切换完全由内核来控制。C



（2012统考）中断处理和子程序调用都需要压栈以保护现场。中断处理一定会保存而子程序调用不需要保存其内容的是（ ）

A 程序计数器

B 程序状态字寄存器

C 通用数据寄存器

D 通用地址寄存器

> 程序状态字（PSW）寄存器用于**记录当前处理器的状态和控制指令的执行顺序，并且保留与运行程序相关的各种信息**，主要作用是**实现程序状态的保护和恢复**。所以中断处理程序要将PSW保存，子程序调用在进程内部执行，不会更改PSW。B



（华中科技大学）中断向量地址是（ ）

A 子程序入口地址

B 中断服务例程入口地址

C 中断服务例程入口地址的地址

D 例行程序入口地址



下列选项中， ____可以执行特权指令？()

A 中断处理例程

B 普通用户的程序

C 通用库函数

D 管理员用户的程序

> 中断处理例程（也可称为中断处理程序）需要执行打开中断，关闭中断等特权指令，而这些指令只能在内核态下才能正确执行，所以中断处理例程位于操作系统内核中。
>
> 而1,3,4都属于用户程序和用于用户程序的程序库。 以ucore OS为例，在lab1中就涉及了中断处理例程，可查看intr_enable，sti，trap等函数完成了啥事情?被谁调用了?




应用程序引发异常的时候，操作系统可能的反应是（）

A 删除磁盘上的应用程序

B 重启应用程序

C 杀死应用程序

D 修复应用程序中的错误

> 【有两种可能：1.杀死产生异常的程序；2.重新执行异常指令来修复程序】更合适的答案是C。
>
> 因为应用程序发生异常说明应用程序有错误或bug，如果应用程序无法应对这样的错误，这时再进一步执行应用程序意义不大。如果应用程序可以应对这样的错误（比如基于当前c++或java的提供的异常处理机制，或者基于操作系统的信号（signal）机制（后续章节“进程间通信”会涉及）），则操作系统会让**应用程序转到应用程序的对应处理函数来完成后续的修补工作**。 
>
> 以ucore OS为例，目前的ucore实现在应对应用程序异常时做的更加剧烈一些。在lab5中有有对用户态应用程序访问内存产生错误异常的处理（参见 kernel/trap/trap.c中的trap_dispatch函数有关 “case T_PGFLT: ”的实现），即ucore判断用户态程序在运行过程中发生了内存访问错误异常，这是ucore认为重点是查找错误，所以会调用panic函数，进入kernel的监控器子系统，便于开发者查找和发现问题。这样ucore也就不再做正常工作了。当然，我们可以简单修改ucore当前的实现，不进入内核监控器，而是直接杀死进程即可。你能完成这个修改吗？



 多选题 (2分)

下列程序工作在内核态的有____()

A 系统调用的处理程序

B 中断处理程序

C 进程调度

D 内存管理

> ABCD.【我没选D，因为我觉得D内存的管理不一定在内核态】这里说的“程序”是一种指称，其实就是一些功能的代码实现。
>
> 而1-4都是操作系统的主要功能，需要执行相关的特权指令，所以工作在内核态。 
>
> 以ucore OS为例（lab5实验）：
>
> 系统调用的处理程序在kern/syscall目录下， 中断处理程序在kern/trap目录下
>
> 进程调度在kern/schedule目录下，内存管理在kern/mm目录下



-----

单选题 (1分)

在使能分页机制的情况下，更合适的外碎片整理方法是()

A 紧凑(compaction)

B 分区对换(Swapping in/out)

C 都不是

> c,分页方式不会产生外碎片



 多选题 (2分)

可有效应对大地址空间可采用的页表手段是()

A 多级页表

B 反置页表

C 页寄存器方案

D 单级页表

> AB.我觉得只有B是对的，对于大地址空间系统，多级页表会变得比较繁琐。
>
> 据说：之所以不选页寄存器，是因为硬件开销会很大，所以现在通用的CPU都没有采用这种方式。个人觉得，页寄存器是一种仅存在于理论中的方法，没有实际意义，所以不应该选C。
>
> 反置页表：不让页表大小与逻辑地址空间大小相对应。
>
> 页寄存器：页表大小相对于物理内存很小，与逻辑地址空间大小无关。




描述段管理机制正确的是()

A 段的大小可以不一致

B 段可以有重叠

C 段可以有特权级

D 段与段之间是可以不连续的

> ABCD



描述页管理机制正确的是()

A 页表在内存中

B 页可以是只读的

C 页可以有特权级

D 上述说法都不对

> ABC,我觉得A不对是因为页表不是有快表可以存在高速缓存中吗？位于CPU内部这样。
>
> 或许是认为是内存而不是外存这样？



页表项标志位包括()

A 存在位(resident bit)

B 修改位(dirty bit)

C 引用位(clock/reference bit)

D 只读位(read only OR read/write bit)

> ABCD。但是PPT上面只介绍了前三种。最后一种我觉得类似于页寄存器中的保护位，来决定该页的访问方式。
>
> 难道都是针对于页的访问，所以应该也有这样的标志位？
>
> 存在位：是否有物理帧相对应。
>
> 修改位：对应页面是否被修改。
>
> 引用位：这个页面在过去一段时间是否对其有引用。



物理页帧数量为3，虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3，请问采用最优置换算法的缺页次数为（）
A 1
B 2
C 3
D 4

> 本来选的是A，这是假定内存中已经预读入了0，1，2这3个页面；
>
> 而实际上，程序在第一次运行时会有大量的缺页发生，因为内存中没有读入任何页面，这就是答案4次的由来，即在前3次读取时都会发生中断。所以是相当于前三次读取页面的时候也要算进去啊D

==【remind】==

物理页帧数量为3，虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3，请问采用FIFO置换算法的缺页次数为（）

A 1

B 2

C 4

D 6

> 为什么是D呢？我不能理解，感觉是4次。就是012进来，然后再换掉2，一共四次？？这样？

![](C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220402112952.png)



物理页帧数量为4，虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 ，请问采用CLOCK置换算法（==用1个bit表示存在时间==）的缺页次数（）

A 8

B 9

C 10 

D 11



物理页帧数量为4，虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 ，请问采用CLOCK置换算法（==用2个bit表示存在时间==）的缺页次数为()

A 8

B 9

C 10

D 11

> ==【我觉得可能需要再看一下clock算法的计数操作？】==9 10



下面哪些页面淘汰算法会产生Belady异常现象（）

A 先进先出页面置换算法（FIFO)

B 时钟页面置换算法（CLOCK)

C 最佳页面置换算法（OPT）

D 最近最少使用页面置换算法（LRU）

> CD.注意题目是淘汰了Belady现象，也就是不会出现该现象。然后CD都是一种栈算法。
