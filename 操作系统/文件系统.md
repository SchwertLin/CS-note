# 文件系统

[TOC]



## 概念

提出：

1. 在进程运行时，可以在它自己的地址空间存储一定量的信息，但是**存储容量受虚拟地址空间大小的限制**。
2. 在进程终止时，**它保存的信息也随之丢失**。
3. 经常需要多个进程同时访问同一信息。

解决方法：**使得信息本身独立于任何一个进程。**



**长期存储信息**有三个基本要求：

1. 能够存储大量信息。
2. 使用信息的进程终止时，信息仍然存在。
3. 必须能使多个进程并发访问有关信息。



文件系统是OS中管理==持久性数据==的==子系统==，提供数据存储和访问功能。

> 能够组织、检索、读写访问数据
>
> 大多数的计算机系统都有文件系统
>
> Google是一个文件系统--负责网上大量的数据检索

文件是具有符号名，由字节序列构成的数据项集合。

> 文件是文件系统的基本数据单位
>
> 文件名是文件的标识符号

文件系统的功能：

1. ==分配文件磁盘空间==

   对于已经分配给用来存数据的文件块：管理文件块的位置和顺序。

   对于空闲空间块：这些空闲空间分布在哪些位置。

   分配空间算法：选择策略。

2. ==管理文件集合==

   定位：给出文件名后找到它的位置并读出它的内容。

   命名：使得人易于理解。

   文件组织方式：文件系统结构。

3. ==数据可靠安全==

   安全性：多层次保护数据安全

   可靠性：持久保存文件；同时避免系统崩溃、文件错误、其他攻击。



文件属性：维护不同的文件属性、为了方便访问。

文件的名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间···

![](https://s3.bmp.ovh/imgs/2022/04/10/4925bccc7c86e1bf.png)

文件头：==文件系统元数据==中的文件信息，包括文件属性以及文件存储位置和顺序。



## 文件

**文件命名**

任何一种抽象机制最重要的特性就是对管理对象的命名方式。所以先从文件文件命名开始介绍。

在进程创建文件时，它会给文件命名。在进程终止时，**该文件仍然存在，并且其他进程可以通过这个文件名对它进行访问**。

**文件扩展名**：通常表示文件的一些信息。在某些系统中，文件扩展名只是一种约定，OS并不强制采用它。对于可以处理多种类型文件的某个程序，这类约定是特别有用的。比如编译器可以利用它来区分哪些是C文件，哪些是汇编。



### 文件描述符

==打开的文件==在内存中所维护的相关信息。

**打开文件的过程：**

```c++
f=open(name,flag);
...
read(f,...);
...
close(f);
```

文件访问模式：进程访问文件数据前必须先打开文件。

内核跟踪进程打开的所有文件，OS为每个进程维护一个打开文件表。文件表内每一项对于一个打开的文件，此时给它一个文件描述符。

> **为什么不直接使用文件的标识而是使用文件描述符？**
>
> 因为在该进程下打开的文件数远小于文件系统中的文件数，因此使用一个更简单的标识来方便访问。



**文件描述符维护的信息：**

1. 文件指针：最近一次读写读写位置（每个进程分别维护自己的打开文件指针）
2. 文件打开计数：当前打开文件的次数（为了最后一个进程关闭文件时，可以把相关文件从打开文件表中移除）
3. 文件的磁盘位置：可能需要缓存数据访问信息
4. 访问权限：每个进程的文件访问模式信息



**文件的用户视图和系统视图**：

用户视图：持久的数据结构（For用户进程）

系统视图：系统提供了访问接口，文件对其而言时字节序列的集合（不同的OS有所不同），OS并不关心存储在磁盘上的数据结构。

OS的文件视图：数据块的集合。

> **数据块与扇区**：
>
> 数据块时逻辑存储单元、扇区时物理存储单元
>
> 数据块的大小可能与扇区的大小不同，通常是几个扇区构成一个数据块。



**用户视图到系统视图的转换**：

==文件系统的基本操作单位是数据块==。

进程读文件：获取字节所在的数据块、返回数据块内对应部分。

进程写文件：获取数据块、修改数据块中对应部分、写回数据块

> 导致了一个**问题**：例如 getc() / putc() 即使每次只访问一个字节的数据，但是也需要缓存目标数据的4k字节。







### 访问模式

OS需要了解进程如何访问文件。

1. 顺序访问：按照字节依次读取。

   大多数的文件访问都是顺序访问。

2. 随机访问：从中间读写。

   不是很常用，但是也很重要：比如在虚拟内存中把内存页存储到对换文件中，对系统性能影响很大。

3.  索引访问：根据数据特征索引。

   通常OS不完整提供索引访问机制，所以一般利用数据库。数据库是建立在索引内容的磁盘访问上的。（OS是一个小型的数据库）



**文件内部结构**

1. 无结构：如单词、字节序列。

2. 简单记录结构：将其分为若干列、这个列的大小可为固定长度或可变长度。
3. 复杂结构：例如格式化的文档（MSWord，PDF）、文本文件还是可执行文件。



**文件的共享和访问控制**

访问控制：指用户可以访问哪些文件，以什么样的方式来访问。

访问权限：读-r、写-w、执行..、删除del、列表ls···

对应到每一个用户，就有文件访问控制列表（ACL），对每个用户都有<文件实体、权限>

>在Unix模式下，<用户|组|所有人，读|写|可执行>
>
><用户、用户所在的组、系统的所有人>
>
>用户(标识)ID：用于识别用户，表明每个用户所拥有的权限及保护模式
>
>组(标识)ID：允许用户成组，并指示了组访问权限



**共享导致的语义一致性**：

当多个进程同时访问共享文件的时候，如何协调？

由于磁盘的 I/O 以及网络延迟的处理而设计简单，与同步算法类似。

> Unix文件系统（UFS，Unix File System）语义：
>
> 1. 对打开文件的写入内容立即对其他打开同一文件的其他用户可见。
>
> 2. 共享文件指针允许 多用户 同时读取和写入文件。
>
>    (无协调控制，全靠应用自己把握)

会话语义：写入内容只有当前文件关闭时可见。

读写锁：提供几种简单的锁机制，由应用自己选择需要何种同步互斥来保证一致性。





### 目录

分层文件系统使得文件以目录的方式组织起来。

目录是一类特殊的文件，目录的内容是文件索引表<文件名，指向文件的指针>

目录是树形结构，使得方便记忆。

#### 目录操作

OS应该只允许内核修改目录，以确保映射的完整性。

对于应用程序，则需要通过系统调用访问目录。

[【命令行工具：文件目录操作】](https://blog.csdn.net/fbz123456/article/details/81416253?ops_request_misc=&request_id=&biz_id=102&utm_term=命令行上目录操作&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-81416253.142^v11^pc_search_result_control_group,157^v13^control&spm=1018.2226.3001.4187)



#### 目录实现

最简单的组织方法是组织称为一个文件名的线性列表，包含了指向数据块的指针。这个方法==编程简单、执行耗时==。

或是Hash表——建立Hash结构的线性表。可以==减少目录搜索时间、但是可能发生散列冲突、同时它的大小是固定的==。



### 文件别名

产生：只有一个文件，但是想给它起>=2个的名字。

原因：方便共享、减少存储空间。

解决方法：

1. 硬链接：多个文件项指向一个文件。
2. 软链接：以“快捷方式”指向其他文件。通过存储真实文件的逻辑名称来实现。

> 对于软链接，删除别名，实际上文件不受任何影响。



#### 文件目录中的循环

指向的下一级子目录同时指向它的父目录，使得出现循环。

处理方法（保证不会出现循环）：

1. 只允许到文件的链接、不允许在子目录的链接。
2. 增加链接时，用循环检测算法确定是否合理。

更多的情况下，在实践中，会限制路径可遍历文件目录的数量。



#### 名字解析（路径遍历）

名字解析：把逻辑名字转换成物理资源（如文件）

1. 根据路径名，在文件系统中找到实际文件位置。
2. 遍历文件目录直到找到目标文件。

> e.g.   解析‘’ /bin/ls‘’
>
> 1. 读取根目录的文件头（在磁盘固定位置）
> 2. 读取根目录的数据块，搜索''bin''项
> 3. ‘’bin‘’项会指向下一级目录的数据块，找到‘’ls’‘项
> 4. 找到后读取ls的文件头

**PWD**：当前工作目录。每一个进程设置一个缺省的目录，它的名字解析从当前目录向下解析。==允许用户指定相对路径来代替绝对路径==。

**文件系统挂载**：文件系统需要先挂载才能访问。未挂载的文件系统被怪哉在挂载点上。







### 文件系统种类

**磁盘文件系统**：以磁盘作文存储介质，在上面存储数据。例如FAT，NTFS，ext2/3，ISO9660等。

**数据库文件系统**：文件特征是可被寻址的。如WinFS。

**日志文件系统**：记录文件系统的修改/事件。

**网络/分布式文件系统**：NFS，SMB，AFS，GFS。

> 文件可以通过网络被共享，文件位于远程服务器。用户在访问文件需要挂接远端服务器上的文件。
>
> 使得标准的系统文件访问被转换为网络上的远程访问。存在标准文件共享协议：NFS for Unix,CIFS for Windows。

**特殊/虚拟文件系统**：管道。





## 虚拟文件系统（VFS）

> **文件系统的实现**：使用分层结构，使得文件系统对上层访问提供统一的文件访问和文件系统控制的系统调用接口。然后中间维护各种文件系统所共同的一些数据结构和常用的操作算法。对下面对不同的实际的文件系统提供相应的访问系统。

为了面对多种不同的文件系统，同时对上提供一个统一的文件接口。

**目的**：对所有不同文件系统的抽象

**功能**：1. 提供相同的文件和文件系统的接口。

​			2. 内部维护所有文件以及文件系统所关联的数据结构。

​			3. 利用高效的查询历程完成对文件系统的遍历。

​			4. 对特定的文件系统模块提供相应的交互接口。



### 基本数据结构

**文件卷控制块**（superblock）：每个文件系统对应一个文件卷控制块，里面描述了文件系统的信息信息。例如文件拥有多少数据块，有多少数据块被分配出去、有多少是空闲的，相应的共享的引用计数等等。

**文件控制块**（inode）：通常所说的索引结点。每一个文件都有以一个文件控制块，包含了文件详细信息如访问权限、拥有者、大小、数据块位置等等。

**目录项**：目录是由目录项组成，每一个目录项对应一个子目录（文件）。他将目录项数据结构以及树型布局编码形成树型数据结构。维护每一个目录项所对应的文件控制块在哪、父目录和子目录在哪。



### 存储结构

对于文件系统的数据结构，需要持久存储在外存（磁盘中的数据块）中。

有时需要被加载进内存（何时加载）：

1. 卷控制块：文件系统挂载时。
2. 文件控制块：文件被访问时。
3. 目录项：在遍历一个文件路径时，没有一个统一的时间。





## 文件缓存&打开文件

文件缓存：从磁盘上读数据到内存，甚至到CPU使用。器件有多种缓存。

### 数据块缓存

数据块按需进行读入内存：

1. 提供`read()`操作：把相应的一整块读入。
2. 预读：预先读取后面的数据块。

数据块使用后被缓存：

1. 假设数据将会被再次使用到（局部性原理）。
2. 写操作可能被缓存和延迟写入。

==两种数据块缓存方式==：

1. 数据块访存。

   读内存的时候要标记是否是磁盘的缓存，然后在以后要访问磁盘的内存的时候先访问这块数据。（把磁盘内的数据在内存做一个反向的缓存）

2. 页缓存：统一缓存数据块和内存页。



虚拟页式存储：逻辑地址结果内核的虚拟存储管理机构映射到物理内存或外存。==来扩展进程可用的逻辑地址空间==。

文件数据块的页缓存：在虚拟内存中文件数据块被映射成页；文件的读写操作被转换成对内存的访问。==但是可能导致缺页  和/或   设置为脏页。==

**问题**：对 对于页面置换算法：局部页面置换确定了进程被分配物理页面的页面数；全局页面置换是给整个系统多少物理页面。如果与磁盘中的缓存混合在一起，需要动态调节物理内存分配。

 

### 打开文件的数据结构

所有打开的文件在OS内必须维护相应的数据结构来记录这些缓存的状态。

**文件描述符**：每个被打开的文件都有一个文件描述符。文件状态信息包含目录项、当前文件指针、文件操作设置等。

**打开文件表**：每个进程有一个进程的打开文件表。而整个系统有一个系统的打开文件表。如果有文件卷有文件被打开，那么该文件卷就不能被卸载。

**打开文件锁**：一些文件系统提供文件锁，用于协调多进程的文件访问。（多个进程共享同一个文件时）==把打开文件访问的协调机制变为应用进程自己协调==。

1. 强制：根据锁的保持情况和访问需求确定是否拒绝访问。

2. 劝告：进程可以查找锁的状态来去决定怎么做。

   ​	（ OS 提供相应的机制使得进程可以查询文件打开和锁的状态）







## 文件分配

**文件分配是指哪些块被分配给一个文件来存它的数据。**如何表示分配给一个数据块的位置和顺序。

### 文件大小

==大多数的文件都很小==：

以至于我们需要对小文件提供很好的支持，块空间不能太大。

==一些文件非常大==：

必须支持大文件（64bit文件偏移），大文件访问需要高效。





### 分配方式

1. 连续分配：分配一个起点，连续的若干块又来存这个文件。
2. 链式分配：类似于链表的结构，在`next`内指明下一块的地址。
3. 索引分配：维护一个索引表，专门用来存序号以及它们的顺序。

**考虑的效率指标**

1. 存储效率：类似外部碎片（在连续分配中出现）。

   每次分配的都是最小单位的一块，所以无法处理内碎片。需要在选择数据块大小时进行考虑。

2. 读写性能：访问速度。

   链式的search速度很慢。



#### 连续分配

文件头指定起始块和长度。

**优点**：文件读取表现好、高效的顺序和随机访问。

**缺点：**碎片存在比较多时，存取效率就比较差。在文件增长（文件长度变化）时，后面的块可能被其他的进程占用。此时应该如何分配呢？时预先留几块空间还是按需分配呢？



#### 链式分配

文件以数据块链表方式存储，文件头包含了到第一块和最后一块的指针。

**优点**：创建、增大、缩小很容易；不存在碎片。

**缺点**：无法做到随机访问。如果要查中间的某一块，则需要从头开始往后找；可靠性差：当中间某操作时弄错了指针，就会导致后面接续的数据丢失。



#### 索引分配

为每个文件创建一个索引数据块，存储有哪些数据块被使用。

**在索引数据块中，存储了指向文件数据块的指针列表；文件头包含了索引数据块的指针。**

**优点**：创建、增大、缩小都很容易；没有碎片；支持直接访问。

**缺点**：当文件很小时，存储索引的开销就会比较大；在处理大文件时（文件大到索引块内的序号无法用一块数据块存下），那么需要多个文件索引块。



## 冗余磁盘阵列RAID

提高文件可靠性和读写性能的一组技术。

### 磁盘

磁盘暂且理解为一种大小固定的块的线性序列，并支持读写的操作。文件时进程创建的信息逻辑单元。一个磁盘一般含有几千or几百万个文件，每个文件是独立于其他文件的，唯一不同的是文件是对磁盘的建模，而非RAM的建模。

###  磁盘分区

在通常情况下，由于磁盘上有磁头的移动(机械运动)，所以它的访问速度就会比较低。**所以磁盘通过分区来最大限度减少寻道时间**。

分区是一组柱面的结合。

文件卷：一个拥有完整文件系统实例的外存空间，通常常驻在磁盘的单个分区上。

#### 多磁盘管理

使用多磁盘进行改善读写性能和可靠性：

1. 吞吐量（通过并行）
2. 可靠性和可用性（通过冗余）

RAID是多种磁盘管理技术，实现方式：

1. 使用软件：OS内核的文件卷管理
2. 使用硬件：RAID硬件控制器（I/O）



**RAID-0：磁盘条带化技术**==提高并行性==

把数据块分成多个子块，存储在==独立==的磁盘中。通过独立磁盘上并行数据块访问提供更大的磁盘带宽。



**RAID-1：磁盘镜像**==提高可靠性==

向两个磁盘写入，从任何一个读取。==读性能提高==。

**优点**：可靠性成倍增长，读取性能线性增加。



**RAID-4：带校验的磁盘条带化**

数据块级磁盘条带化+装用奇偶校验磁盘。

**优点**：允许从任意一个故障磁盘中恢复。
