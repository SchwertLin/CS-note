# 指令系统

[TOC]

指令：是指计算机完成某种功能的指令。

机器指令：计算机可直接识别并执行的命令，也称机器语言。

程序：一组完成某种功能的指令的集合。

指令系统：一台计算机所能执行的指令的集合称为该计算机的指令系统。

设置指令系统的要求：**完备性、有效性、规整性、兼容性**





## 指令系统结构层

指令系统结构层主要定义计算机的存储模式、寄存器组织、数据类型以及指令等信息。

### 存储模式

存储模式定义包括存储器结构、特殊存储区（如堆栈等）、数据存储顺序、边界对齐等相关事宜的确定。

**按字节编址的存储器**：大多数系统的主存将一个存储单元定义为8 bit（1 byte），以方便对不同长度的数据类型进行存储。

==对于机器字长为32bit的系统，一个32位数据称为一个字，由4byte组成，在主存存储时占用4个地址连续的byte单元。==

==对于机器字长为64bit的系统，一个64位数据称为一个字，由8byte组成，在主存存储时占用8个地址连续的byte单元。==



**数据存储顺序**（简明扼要）：

1. 大端存储：最小的排在最前面。
2. 小段存储：最大的排在最前面。

**边界对齐**：所谓边界对齐是指数据存储在低位地址以全0开始的连续存储单元中。



**堆栈**：在所有计算机系统之中，对于主存大部分空间，允许在任何时间对其中的任何存储器元进行存储操作，且读写时间相同，这种特性称为主存的随机读写特性。但是它具有FILO的操作规则。

在堆栈之前，先要对堆栈的大小、在主存中的位置做出定义。使用堆栈时用三个专用地址寄存器来管理：

1. 堆栈指针（SP）：指示当前可操作的堆栈单元。
2. 堆栈基址（SB）：指示堆栈的底部。
3. 堆栈界限（SL）：指示堆栈的最顶端。

堆栈界限 = 堆栈基址 $\pm$ 堆栈大小



**冯·诺伊曼结构**

指指令和数据混合存储。在冯·诺伊曼计算机中规定，指令和数据均用二进制表示，并可在整个主存中混合存放。从指令系统结构层的角度看，整个主存就是单一的线性地址空间。

**优点**：指令和数据可以共享并充分利用主存资源。

**缺点**：不正确的数据操作可能会破坏指令，造成程序无法正常运行。



**哈佛结构**

将主存分为指令地址空间和数据地址空间两部分，所有的程序都必须放在指令地址空间中，所有数据都必须放在数据地址空间中。

**优点**：

1. 由于指令存储器只需要读取操作，这使得指令存储器的设计、控制变得较为简单；并且可以加快读出的指令的速度。
2. 所有的写操作都自动在数据存储器中执行，避免了数据对程序可能造成的破坏，减少了程序出错的机会。
3. 利用n位地址可以获得2个$2^n$大小的地址空间（数据空间+程序空间）

**缺点**：指令存储器和数据存储器可能得不到充分的利用。







### 寄存器组织

从指令系统结构层次来看，寄存器时软件设计者唯一能操作的CPU资源。

寄存器的定义包括：寄存器功能、寄存器所属层次、寄存器规模、寄存器字长等信息的确定。

**基本功能**：为CPU运行提供所需要的信息，保存CPU运行产生的结果。

**主要功能**：对频繁使用的数据进行快速访问。

**分类**：通用寄存器和专用寄存器。

在所有的寄存器中，有些寄存器是指令系统结构层可见的寄存器，有些寄存器是微体系结构层可见的寄存器。一般而言，==微体系结构层可见的寄存器在指令系统结构层是不可见的，而指令系统结构层可见的寄存器在微体系结构层一定可见。==

1. 指令系统结构层可见的寄存器：一部分用户程序可见：通用寄存器。另一部分只允许在内核模式下OS使用的专用寄存器。
2. 微体系结构层可见的寄存器：专业寄存器。不可以程序访问。（如指令寄存器）





总共有14个16位寄存器,8个8位寄存器。

#### 通用寄存器

数据寄存器:

| **AH(8位)** | **AL(8位)** | **AX(16位)** | **AX和AL又称累加器**                                 |
| ----------- | ----------- | ------------ | ---------------------------------------------------- |
| **BH(8位)** | **BL(8位)** | **BX(16位)** | **BX又称基址寄存器,唯一作为存储器指针使用寄存器**    |
| **CH(8位)** | **CL(8位)** | **CX(16位)** | **CX用于字符串操作，控制循环的次数,CL用于移位**      |
| **DH(8位)** | **DL(8位)** | **DX(16位)** | **DX一般用来做32位的乘除法时存放被除数或者保留余数** |

  指针寄存器:

| SP     | 堆栈指针     | 存放栈顶地址，与堆栈寄存器一起确定堆栈在内存中的位置 |
| ------ | ------------ | ---------------------------------------------------- |
| **BP** | **基址指针** | **存放堆栈基址**                                     |

  变址寄存器:==用于指令的变址寻址==。

| SI     | 源变址       | 源变址寄存器       |
| ------ | ------------ | ------------------ |
| **DI** | **目的变址** | **目的变址寄存器** |

  

#### 控制寄存器:

分为IP 指令指针和标志寄存器（PSW）。

| CF     | 进位标志       | 记录运算时最高有效位产生的进位值                             |
| ------ | -------------- | ------------------------------------------------------------ |
| **SF** | **符号标志**   | **记录运算结果的符号。结果为负时置1，否则置0**               |
| **ZF** | **零标志**     | **运算结果为0时ZF位置1，否则置0**                            |
| **OF** | **溢出标志**   | **在运算过程中，如操作数超出了机器可表示数的范围称为溢出。溢出时OF位置1，否则置0** |
| **AF** | **半进位标志** | **记录运算时第3位（半个字节）产生的进位值**                  |
| **PF** | **奇偶标志**   | **为机器中传送信息时可能产生的代码出错情况提供检验条件。当结果操作数中1的个数为偶数时置1，否则置0** |



#### 段寄存器

| **CS** | **代码段寄存器** |
| ------ | ---------------- |
| **DS** | **数据段寄存器** |
| **SS** | **堆栈段寄存器** |
| **ES** | **附加段寄存器** |







## 指令设计

为了使指令能够有效地指挥计算机完成各种操作，一条指令应该包含两个基本要素：操作码和地址码。

$OP+ADDR$

### 指令信息

![](https://s3.bmp.ovh/imgs/2022/04/12/6e231058bb44ac98.png)

寻址方式字段的位数与支持的寻址方式种类有关、地址码字段的作用与支持的寻址方式种类有关。

并不是每条指令都一定会包括这四种信息。==只有指令操作码式每一条指令必须具有的==以外，其他学校的有无依据指令而异。

**1.指令操作码**

指令操作码用来规定指令所完成的功能。用不同的二进制编码来设定指令操作码，每一种编码对应一条指令。==操作码字段的位数与支持的最大指令数量有关==。

**2.操作数地址**

指令中指出操作数的地址，处理器便可以依地址获得操作数。地址通常是存储单元、I/O接口或是CPU的内部寄存器。

**3.操作结果的存放地址**

地址通常是存储单元、I/O接口或是CPU的内部寄存器。

**4.下一条指令的地址**

顺序执行时：由CPU中的程序计数器（PC）给出。

转移或是调用子程时：由指令给出。



### 指令分类

![](https://s3.bmp.ovh/imgs/2022/04/12/7370d7089438a848.png)

三地址指令：对于A1A2中的数据进行操作，然后将得到的数据写入A3。

二地址指令：对于A1A2中的数据进行操作，==等到运算结果稳定以后==，再将数据写入A1。

一地址指令：将累加器AC（通用寄存器）与A1的中的数据进行操作，把数据写到AC中。

零地址指令：不需要操作数，只要操作码。往往不需要对相应的数据进行操作。

多地址指令：在一些性能较好的处理器中，会设置一些多地址指令。



![](https://s3.bmp.ovh/imgs/2022/04/12/d8d9922b3ed7b4c0.png)

SS：第一个操作和第二个操作都是来自主存，取两个操作数要访问主存两次，比较慢，被out了。

RR：两个操作数都来自寄存器。很快。

RS：SS与RR的中和。一个操作数来自主存，一个来自于寄存器。

![](https://s3.bmp.ovh/imgs/2022/04/12/604a98a0acdbb890.png)



### 指令字长

指的是指令中包含的二进制位数。与机器字长相比，分为单字长、双字长、半字长等长度指令。==如何理解长度指令==？

对于多字长指令（>=2）:是为了解决寻址较大存储空间的问题、取指令多次访问内存，会影响苏，占用的空间大。

对于等长指令：不同类型的指令，指令长度固定。对于硬件的设计简化有帮助。

对于变长指令：指令的长度可根据需要有所调整。

**指令长度的影响因素**：构成一条指令的二进制位数成为指令长度。从规整性的角度考虑，指令长度都是字节的整倍数。在设计CPU的指令系统式，指令的长度受到多种因素的影响，设计者在设计CPU的指令系统时必须考虑这些因素。

1. 内存大小和组织

   基本上，好像都是内存按==字节==编址来存放指令。(不是字)

2. CPU数据总线的宽度

   指令长度应为CPU数据总线宽度的整数倍，可以避免在取指周期内得不到整齐数目的指令。

3. CPU内部寄存器的数量

   内部寄存器越多，CPU的功能越强，对CPU内部寄存器的读写速度是最快的。

4. 寻址方式

   寻址方式越多，则构成的指令系统的功能就越强，编程效率也会越高；但是寻址方式越多，用于描述它们的编码就越长，指令长度也必然加长。

5. 指令数量

   设计CPU指令系统的指令越多，用于指令操作码的编码也就会越长，影响指令的长度。





### 操作码设计

操作码是用来指示计算机执行某种操作或完成某种功能的，每一条指令有唯一确定的操作码，不同指令的操作码用不同的二进制编码表示。操作码字段的设计主要采用两类编码方式：==操作码长度固定和操作码长度可变。==



#### 定长操作码

对所有指令的操作码用相同位数的二进制数进行编码即为定长操作码编码方式。

> 假设某计算机的指令系统需要设置N条指令，若所有指令的操作码均用n位二进制数表示，那么应该满足关系式：$N\le2^n$。从$2^n$个编码中选出N个编码分配给N条指令，即可完成操作码设计。

**优点**：操作码构造简单，有利于简化硬件设计、提高指令译码和后续执行速度。

**缺点**：操作码占用指令空间较大，且指令规模（条数）扩充受到限制。



#### 可变操作码

对于不同类型的指令操作码用不固定长度的二进制数进行编码即为变长操作码编码方式，也称作==扩展操作码编码方式==。

扩展操作码技术是一种重要的指令优化技术。

其技术核心是：

1. 使程序中指令的平均操作码长度尽可能短，以减少操作码在程序中的总位数。
2. 尽可能充分地利用指令的二进制数位，以增加指令字表示的操作信息。

其设计原则是：

1. 如果指令字长固定：长地址码对应短操作码，操作码长度随地址码长度缩短而增加。
2. 如果指令字长可变：（Huffman）则以指令使用频度作为设计依据，使用频度高的指令用短操作码，频度低的指令用长操作码。
3. 设计总从短操作码开始，并要保证当前使用的操作码编码与未来要扩展的操作的编码能够有效区分。





#### 错题

![](https://s3.bmp.ovh/imgs/2022/04/13/4f53450324ddd850.png)

B：零地址指令。

D：**地址码**：指令中指定操作数存储位置的字段称为地址码，地址码中可以包含存储器地址。也可包含寄存器编号。（嗯···怎么不算是数据呢？）

指令中可以有一个、两个或者三个操作数，也可没有操作数，根据一条指令有几个操作数地址，可将指令分为零地址指令。一地址指令、二地址指令、三地址指令。4个地址码的指令很少被使用。



![](https://s3.bmp.ovh/imgs/2022/04/13/c980e7e860f4ef29.png)

RR型指令，要考虑OP+A1+A2（8+4+4）这里要考虑的是地址字段占8个，然后不能忘记对于操作数也要占用一定的位数。所以16位可。













## 寻址方式

**寻址方式就是指令获取操作数的方式**。

顺序存放：重新的指令序列在主存顺序存放。执行时从第一条指令开始，逐条去除并逐条执行，这种重新的顺序执行过程，称为顺序寻址。

> 在CPU种设置PC（程序计数器）对指令的顺序号进行计数，PC开始时存放重新的首地址，每执行一条指令，PC+1，指出下调指令的地址，直至程序结束。
>
> ‘’+1‘’：==指的是存储1条指令所占用的字节单元数==。



跳跃寻址：由转移类指令实现，包括有条件的和无条件的。内存里面放置的是无条件转移指令（下一条指令的地址）然后会跳转到下一条指令所在的地址。对于有条件的需要判断PSW中的相应条件是否满足再确定是否要跳转。

![](https://s3.bmp.ovh/imgs/2022/04/13/18e32a0fe5fa1454.png)

A：有效地址：当操作数存放在主存单元中时，若指令中的地址码不能直接用来访问主存，则将这样的地址码称为形式地址，对形式地址进行一定的计算而得到的存放操作数的主存单元的地址。

C：或许有的指令并不需要，隐式寻址？





### 操作数寻址方式

形成操作数有效地址的方法就是操作数寻址方式。

寻址方式在指令中以两种方式呈现：

1. 由操作码决定器寻址方式，称为隐式寻址。
2. 指令中设置寻址方式字段，由寻址方式字段的不同编码来指定操作数的寻址方式，称为显式寻址。

==由于操作数不一定在主存中，所以当涉及到计算其有效地址的时候，那一定指的是数据在主存之中==。`S=(E)`



**隐含寻址**：操作数的存放由操作码指定。
隐含，就是不明显。隐含寻址就是不明显的给出操作数的地址，操作数的地址隐含于操作数或某个寄存器内，例如，一地址格式的加法指令只给出一个操作数的地址，另外一个操作数的就隐含在ACC累加器中，这样，累加器的地址就是操作数的地址。

这种隐含寻址的方式在指令字中就少了一个地址，有利于缩短指令字长。

> 以Intel指令为例，加法十进制调整指令DAA隐含规定调整对象为寄存器AL，乘法指令MUL BL隐含规定乘数之一式8位寄存器AL，乘积存放在16bit寄存器AX中。





**立即数寻址**：地址码字段是操作数本身。（数据很快得到）

`MOV AX,200H`(AX←200H)   `S=D`

特点：

1. 取指操作将数据与指令一并读入CPU内部的寄存器，指令执行速度块；
2. 便于查询设计（变量赋初值）
3. 数据大小受字段位数限制。



**寄存器寻址**：操作数已经在CPU内部的寄存器中。

`MOV AX,BX`   (AX←BX)

特点：

1. 操作数在寄存器中，指令执行速度快。
2. 能够访问的数据大小一般与计算机字长有关。（对于寄存器寻址，给的指令地址字段是寄存器的编号字段）只限制了能够使用的通用寄存器的数量，并没有限制所获得的数据大小。
3. 地址字段的位数与计算机通用寄存器数量相关。



**直接寻址**：地址码字段直接给出操作数在内存的地址。`E=D,S=(D)`

`MOV AX,[200H]`

特点：

1. 提供了访问了主存操作
2. 获得数据要访问主存，指令执行速度慢
3. 地址字段的位数决定了访存空间大小



**间接寻址**：地址码字段给出的是操作数地址的地址，`E=(D),S=((D))`

`MOV AX,I[200H]`——访问主存两次才能得到数据。

特点：

1. 解决了直接寻址方式下地址字段的位数限制访存范围大小的问题。
2. 获得数据要访问主存两次，指令执行速度太慢。



**寄存器间接存址**：地址吗字段给出的是寄存器编号R，`E=(R),S=((R))`

`MOV AX,[BX]`

特点：

1. 缓解了直接寻址方式下地址字段的位数限制访存范围大小的问题。
2. 获得操作数只需要访问主存一次。



**相对寻址**：`E=D+(PC)`,D为指令中地址字段的值

特点：

1. 可节省指令中的地址位数，便于程序再内存中成块移动。

2. 注意PC的改变对计算E的影响，如`E=200+2000+[2]`是因为PC的值在取值以后要+2（前提是计算机采用双字节长指令）

   如果计算机是32位字长，那么应该+4。



**基址寻址**：指定一个基址寄存器B，与本质了地址无关。`E=D+(B)`，D位指令中地址字段的值。

`MOV AX,32[B]`

特点：

1. 使用基址寄存器可以访问更大的主存空间。
2. 对于某一程序而言，基址设定后不变，故要访问不同数据修改D。



**变址寻址**：指定一个变址寄存器X，与本指令地址无关，内容可随要求改变。`E=D+(X)`,D位指令中地址字段的值。

`MOV AX,32[SI]`,SI(DI)都称为变址寄存器。

特点：不改变指令即可改变数据的有效地址，可以在循环中使用。



![](https://s3.bmp.ovh/imgs/2022/04/14/c72e6a282b9b9db5.png)

对于64位的计算机，一个字=64bit，所以单字长的只需要存放在主存的一个地方。但是对于间接寻址，就需要访问主存两次。

==当时迷失在64位计算机和单字长指令之中了，还在想这和做题有什么关系==。



![](https://s3.bmp.ovh/imgs/2022/04/14/d7a7d623194f2a2c.png)

==不小心只选了一个。==





## 指令格式设计

![](https://s3.bmp.ovh/imgs/2022/05/16/de08269ea2bf308c.png)

使用操作码扩展是在指令长度不变的情况下。

拿32位单字长二地址指令，每个地址码为12位（含寻址方式字段）为例：若已经定义了250条二地址指令，则还可以定义多少条单地址指令？此时的单地址指令以前面二地址指令未用到的编码作为扩展码，同时因为是单地址码，所以原来二地址操作码用作地址的位数被用于编码。所以是$6*2^{12}=24k$。



![](https://s3.bmp.ovh/imgs/2022/05/16/506b76b9b01aa0b1.png)

寄存器寻址不行：E=R，计算机的字长是32位，寄存器寻址需要事先往寄存器存好地址,可以通过把立即数放到寄存器实现,32位的指令,去掉操作码和寻址方式(32bit-8bit-2bit=22bit),剩下22位,假设寄存器不超过2个,最少只占用一位编号,最多剩下21位表示一个立即数,这个立即数最大$2^{21}=2M<4M$。







![](https://s3.bmp.ovh/imgs/2022/05/16/766993361419b44a.png)

8指的是8byte=64bit=2word=双字长。

RS指的是，一个操作数在通用寄存器，另一个操作数在主存中。 ==注意，这里的主存=内存。==

取指令两次访存，该指令需要内存上存两个单元，执行指令一次访存。

> 这条指令原先放在主存上，然后这条指令的长度是双字长，所以需要访问两次来取该指令。然后再对指令里面的一个操作数（在主存上的那个）进行一次访问。





## MIPS(RISC)

对于RISC的主要特点如下：

1. 只设置使用频度高的一些简单命令，复杂指令的功能由多条简单指令的组合来实现。
2. 指令长度固定，指令种类少，寻址方式种类少。
3. 访存指令很少，有的PISC只有LDA和STA两条指令。多数指令的操作在速度快的通用寄存器间进行。
4. CPU中设置大量的通用寄存器，一般有几十甚至几百个。
5. 控制器采用硬件实现，采用组合逻辑控制器。
6. 有利于优化编译程序。
7. 可简化硬件设计，降低设计成本。

MIPS是没有内部互锁(完成顺序与发射顺序不一致)流水线的微型机。

<img src="https://s3.bmp.ovh/imgs/2022/05/16/328391d19ce9abd9.png" style="zoom:67%;" />

<img src="https://s3.bmp.ovh/imgs/2022/05/16/e75d8a2248232cf7.png" style="zoom:80%;" />



<img src="https://s3.bmp.ovh/imgs/2022/05/16/316b80ac8f24150e.png" style="zoom:80%;" />

![](https://s3.bmp.ovh/imgs/2022/05/16/e84cb12eae65e9ac.png)

<img src="https://s3.bmp.ovh/imgs/2022/05/16/f709e9803b081e1e.png" style="zoom: 67%;" />



<img src="https://s3.bmp.ovh/imgs/2022/05/16/80964bb707e879c6.png"  />

MIPS体系结构有 : 32个通用寄存器，2个特殊寄存器（整数乘除法寄存器）， 32个浮点寄存器。
PC：在MIPS体系结构下，PC不是一个通用寄存器。



![](https://s3.bmp.ovh/imgs/2022/05/16/1deb87e7ed82f6fd.png)

D之所以错，我认为是I型指令以及J型指令内均有立即数字段。但是对于不同型号的指令，它们的立即数字段并不相同。



![](https://s3.bmp.ovh/imgs/2022/05/16/e692e7afbdc4b9e2.png)

<img src="https://s3.bmp.ovh/imgs/2022/05/16/f709e9803b081e1e.png" style="zoom:67%;" />





## 一些问答&解惑？

### 适于访问数组的是变址寻址

**变址寻址**：指定一个变址寄存器X，与本指令地址无关，内容可随要求改变。`E=D+(X)`,D位指令中地址字段的值。

`MOV AX,32[SI]`,SI(DI)都称为变址寄存器。

特点：==不改变指令即可改变数据的有效地址==，可以在循环中使用。



### 有利于缩短指令地址码长度的是隐含寻址

隐含寻址主要是将一个操作数隐藏起来(指的是虽然它没有在指令中显示出来，但是能够找得到)。所以就会使地址码缩短，毕竟直接一整个没了です。



### 操作数与有效地址

**操作数（operand)**：是 计算机指令中的一个组成部分，它规定了指令中进行数字运算的量。操作数指出指令执行的操作所需要数据的来源。操作数是汇编语言指令的一个字段。例如：`mov a b `操作数（a 和 b）。在操作数这个字段中可以放操作数本身，也可以放操作地址，还可以放操作地址的计算方法。

​		通常一条指令均包含 操作符和操作数。例如：在比较指令中操作符指定计算机做比较操作，操作数则指定进行比较的两个数值。操作数是指令执行的参与者，也就是各种操作的对象。与之有关的是操作码，所谓操作码是说明计算机要执行哪种操作：如传送、运算、移位、跳转等，它是指令中不可缺少的组成部分。



**有效地址**：当操作数存放在主存单元中时，若指令中的地址码不能直接用来访问主存，则将这样的地址码称为形式地址，对形式地址进行一定的计算而得到的存放操作数的主存单元的地址。

