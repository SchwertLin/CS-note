# 总复习

![](https://s3.bmp.ovh/imgs/2022/06/06/747f167878761af9.png)

## 绪论

### 计算机的发展

现代计算机的==理论基础==：布尔代数、==物质基础==：双稳态触发器。

1946年，美国，ENIAC，电子数字积分和计算机

1946年6月，冯·诺伊曼提出以二进制，程序存储和程序控制为核心的思想，==奠定了当代电子数字计算机体系结构的基础==。

- 1946-1954年，第1代，电子管计算机，ENIAC、IBM 701
- 1955-1964年，第2代，晶体管计算机，IBM 7030、Univac LARC
- 1965-1974年，第3代，集成电路计算机，IBM 360、370、DEC PDP-8
- 1975-1990年，第4代，超大规模集成电路计算机，IBM 3090、VAX 9000、PC机、苹果机
- 1991-，第5代，多核处理器（4核和8核）



### 计算机的基本组成

![](https://s3.bmp.ovh/imgs/2022/06/06/953808da12ac0696.png)

==这是去年的考题！！！==

冯·诺伊曼机的硬件固定，==不同的运算功能依靠预先放在存储器中的程序实现==，这是存储程序控制的基本原理，也是区别其他运算工具的关键。

![](https://s3.bmp.ovh/imgs/2022/06/06/f31e31c05eac787b.png)



**计算机的软件**：

- 计算机语言：机器语言、汇编语言、高级语言
- 软件分类：系统软件、应用软件、中间件



### 计算机的层次结构

![](https://s3.bmp.ovh/imgs/2022/06/06/811c3d8446a22bea.png)



### 计算机的分类

- 按照规模和功能分类：

  巨型机、大型机、中型机、小型机、微机、单片机

- 按用途分类：

  通用机（如：PC机）、专用机（如：嵌入式计算机）

- 按信息处理的特性分类：==（FLYNN）费林分类法==

  1. 单指令流单数据流计算机（SISD）
  2. 单指令流多数据流计算机（SIMD）
  3. 多指令流单数据流计算机（MISD）
  4. 多指令流多数据流计算机（MIMD）



Flynn分类法：按照计算机在执行程序的过程中信息流的特征进行分类的。

![8](https://s3.bmp.ovh/imgs/2022/06/06/767d3ceb251db1b1.png)





### 计算机的性能描述

（个人认为可能概率会出题）

- MIPS：每秒钟执行指令的百万条数
- MFLOPS：每秒钟执行浮点数的百万次操作的数量
- CPI：每条指令执行所用的时钟数
- N：每条指令执行所用的时钟数
- $f_{CLK}$：时钟频率

![](https://s3.bmp.ovh/imgs/2022/06/06/3b929200f2274023.png)

---------

![](https://s3.bmp.ovh/imgs/2022/06/06/3f1b643efd3b5142.png)





## 计算机中的数据表示

![](https://s3.bmp.ovh/imgs/2022/06/06/781abaaa7f6d295e.jpg)

![](https://s3.bmp.ovh/imgs/2022/06/06/0a50caa0dd5c58da.png)



### 不同编码的比较

>1. 真值为 + ：原码、补码、反码的表示形式均相同。
>2. 真值为  - ：原码、补码、反码的表示形式不同。
>3. 特殊的移码： 0 表示真值是负数； 1 表示真值是正数。

==0有唯一的编码==：补码、移码。

>原码：1000 0000 | 0000 0000
>
>反码：1111 1111 | 0000 0000

==符号位用0表示正、用1表示负==：原码、反码、补码

>移码：1表示正、0表示负

==满足真值大则码值大==：移码

> 最高位符号位1为负数（真值小码值小）：原码、反码、补码

==存在负值的真值越大码值越小==：原码

>【-1】补=【1000 0001】补=【1111 1111】可见是：最大的负值、最大的码值。
>
>反码 = 补码 - 1、移码 = 补码最高符号位取反 因此均不是。

==负数的码值大于正数的码值==：原码、反码、补码

> 原理是：负数的码值最高位符号位为1



### 浮点数

规格化指的是尾数的绝对值限定在$\frac{1}{2} $~$ 1$之间。

若$M\ge0$：$M=0.1XX...X$是规格化数。

若$M\lt0$：由于$[-\frac{1}2]_{补}=1.1000...0$、$[-1]_{补}=1.000...0$。==为了使计算机判断方便，一般不把$[-\frac{1}2]$列为规格化的数，而把$[-1]$列为规格化的数。==$M=1.0XXX...X$时，是规格化数。

![](https://s3.bmp.ovh/imgs/2022/06/06/7ae803cb8265a010.png)

==貌似左规和右规都是在采用了双符号位，也就是变形补码后产生的。==

**左规**：结果的尾数为$00.0XXX...X$或$11.1XXX...X$的形式时，需将尾数左移1位，阶码 -1，**直到尾数为规格化形式为止**。

**右规**：当浮点运算结果的尾数出现$01.XXX...X$或$10.XXX...X$的形式时，**并不一定溢出**，将尾数右移1位，阶码 +1，然后判断**阶码**是否溢出。

![](https://s3.bmp.ovh/imgs/2022/06/06/14d5bc2f83dce320.png)

![](https://s3.bmp.ovh/imgs/2022/06/06/93a0bdde09679128.png)

![](https://s3.bmp.ovh/imgs/2022/06/06/d40d385e76c4cd27.png)

#### IEEE754

![](https://s3.bmp.ovh/imgs/2022/06/06/c29e8a1bbadb7397.png)

**单精度格式：**1+8+23（符号+阶码+尾数）

![](https://s3.bmp.ovh/imgs/2022/06/06/11c6dcb2e4dce176.png)

==更多的重点还是放在单精度的浮点数上，至于双精度格式（1+11+52）只是被提了一下。==





## 运算方法和运算器



## 指令系统和汇编语言



## 处理器设计