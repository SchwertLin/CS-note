# 运算方法及运算器

[TOC]



## 定点数运算

### 加减

#### 1）补码

==使得CPU的设计只需要加法器就能完成加法与减法运算。==

**加法**：$[X+Y]_补=[X]_补+[Y]_补$

**减法**：$[X-Y]_补=[X]_补+[[Y]_{补}]_{求补}$

(==注意：先补再求补，顺序不可调换==)

**求补**：对于正数求补（全部取反+1）得到其负数。X - Y = X + ( - Y)

> 将减法转换为加法实现。



#### 2）移码

对两方移码求和/差后将结果取反。

> 注意==$[X]_{移}+[Y]_{移}\ne[X+Y]_{移}$==
>
> 要对==符号位取反==

<img src="C:\Users\林颐\Desktop\笔记\图片库\{0N8$LNRTZIZY]CTTYYJV~1.png" style="zoom:67%;" />

> **机器零**：指**机器数所表示的零的形式**。 
>
> 机器零与真值零的区别是：机器零在数轴上表示为0点及其附近的一段区域，即在计算机中小到机器数的精度达不到的数均视为“机器零”，而真值零则表示0这一个点。





#### 3）溢出

**上溢：**运算结果大于+127

**下溢：**运算结果小于-128

**出现的错误**：当两个正数相加，可能出现负数。两个负数相加也可能会出现正数。

e.g.   0100 0001 + 0100 0011 = 1000 0100 || 1000 1000 + 1110 1110 = 0111 0110



**溢出的判定**(OverFlow)

==①双符号位判决法(变形补码)==

采用两位表示符号（00 = + 、11 =  - ）若是发生溢出、则两位符号位就不一致。

==②进位判决法==

若$C_{n-1}$为最高==值位==向最高位（符号位）的进位、$C_n$表示符号位的进位。判别：==$OF=C_{n-1}\oplus C_n$==

当为OF = 1时，则发生溢出。





#### 4）加法器

**一位全加器：**
$$
\begin{cases}Z_i =X_i\oplus Y_i\oplus C_i\\
C_{i+1}=(X_i\cdot Y_i)+(X_i+Y_i)\cdot C_i\end{cases}
$$
**n位加法器**：

①行波进位加法器

==由于进位是逐位形成的，进位会产生延时。速度慢。==

<img src="C:\Users\林颐\Desktop\笔记\图片库\@9MAI_5NU[~R`1WD2N0KQF8.png" style="zoom: 80%;" />



②先行进位加法器

==在进行加法运算之前，先将各位全加器所需要的进位产生出来，加快加法运算的速度。==

<img src="C:\Users\林颐\Documents\Tencent Files\874188502\FileRecv\MobileFile\3A0C052346949E5F341717845160209D.png" alt="3A0C052346949E5F341717845160209D" style="zoom: 33%;" />



在设计加法器是会将多位加法器进位生成电路分组（例如以四组为一组），将各组进位串联在一起，即组内采用先行进位、组与组之间采用行波进位。或是均是先行进位。



③BCD数加法器

应用最广泛的是8421BCD码。

>压缩BCD数：一个字节表示两个BCD数。
>
>非压缩BCD数：一个字节只表示一个BCD数，高位四位为0000。

为保证BCD数加法运算结果的准确性，必须对结果进行校正。

>1. 低四位相加的结果大于9或有向高四位进位，结果 + $(06)_H$
>2. 高四位相加的结果大于9或有向Bit7甚至更高位的进位，结果 + $(06)_H$ 且进位为1且将其看作是相加结果的最高位。（==不理解==）
>
>3. 若同时满足上述的条件，则校正时 + $(66)_H$

![](C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220224110326.jpg)

![](C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220224110340.jpg)







### 乘法

通过硬件来实现乘法。速度最快的时全部由硬件实现的==阵列乘法器==。

#### 1）原码一位乘法

$[X]_{原}=X_0 .X_{-1}X_{-2}\cdots X_{-(n-1)}$

$[Y]_{原}=Y_0 .Y_{-1}Y_{-2}\cdots Y_{-(n-1)}$

注意的是符号位为$X_0$ 与 $Y_0$ ,所得到的是 ==$Z_0=X_0\oplus Y_0$== (异或)

==符号位单独运算==

>× 被乘数左移
>
>√ 部分积右移
>
>是因为计算机的字长是有限的（固定字长）。左移可能会发生溢出操作。

逻辑实现

<img src="C:\Users\林颐\Desktop\笔记\图片库\C2C7A2557B17559F8410D150106C3353.png" style="zoom: 33%;" />



#### 2）原码两位乘法

> 基于目前计算机内字长为32/64bit，乘数以及被乘数的长度很长。每次仅进行一位的判定，乘法效率会非常低下。

为了解决这个问题，提高乘法的执行速度，可以考虑每次对乘数的两位进行判断。

1. ==符号位单独运算==

2. 被乘数与部分积均采用三符号位参与运算

3. 乘数末尾增设一位C，初始值0
4. 运算表如下：

<img src="C:\Users\林颐\Desktop\笔记\图片库\321D2D2A2A9DF4812B066AAD400EEDB7.png" style="zoom: 40%;" />

> **若尾数n为偶数，那么乘数采用双符号位，最后一步计算不移位**
>
> **若尾数n为奇数，那么乘数采用单符号位，最后一步计算移一位**





#### 3）补码一位乘法

由于平常机器中采用补码形式表示数据，因此出现使用补码乘法器进行乘法运算。

==符号位参与运算==

以下是Booth法的运算规则。

<img src="C:\Users\林颐\Desktop\笔记\图片库\F.png" style="zoom:80%;" />

<img src="C:\Users\林颐\Desktop\笔记\图片库\1F3523A721E8E3425710C0CA01B87493.png" style="zoom:33%;" />



#### 4）补码两位乘法

1. 被乘数与部分积均采用三符号位
2. 乘数末尾增设一位$Y_{n+1}$  ，初始值为0
3. 运算表如下：

<img src="C:\Users\林颐\Desktop\笔记\图片库\D62165AA464910E56B990F12FA13F5F6.png" style="zoom:45%;" />

> **若尾数n为偶数，那么乘数采用双符号位，最后一步计算不移位**
>
> **若尾数n为奇数，那么乘数采用单符号位，最后一步计算移一位**



#### 5）阵列乘法器

上述的运算利用简单的硬件进行多次加法以及移位的方法实现乘法，因此难以获得较高的运行速度。阵列乘法器是通过硬件结构复杂化来获取较高的运行速度。

**手算及单元电路**（相当于是介绍会使用的一个基本单元）

其思路就是把人工手算的一个过程电路化。

**绝对值阵列乘法器**（把这些单元组合成一个乘法电路）

利用手算算式的结构以及乘加电路可以方便的实现绝对值阵列乘法器。

**带符号的阵列乘法器**：

1. 先求被乘数与乘数的绝对值
2. 进行绝对值乘法
3. 对其符号进行运算



### 除法

#### 1）原码除法

<img src="C:\Users\林颐\Desktop\笔记\图片库\8B16F8A94E0BB49040531E714F27F1DE.png" style="zoom:40%;" />

**恢复余数法**
●符号位单独处理。
对于定点纯小数，被除数左移一位，减除数后：
若够减，上商为1;
若不够减，上商为0，同时加除数(恢复余数) 。

> ●余数左移一位，减除数：
> 若够减，上商为1;
> 若不够减，上商为0，同时加除数(恢复余数)
> ●重复上述过程直到除尽或精度达到要求。
> ●拼接商符得到商，即可获得除法的结果。



**加减交替法**（不恢复余数码）

是恢复余数码的优化：

>恢复余数是每一步先减，减完发现余数居然小于0了。
>
>我就马上加上除数，让它变正。再进行下一步操作。

==而加减交替是考虑余数的正负，从而确定每一步到底是先加还是先减。==

<img src="C:\Users\林颐\Desktop\笔记\图片库\_@HN~46UXAE6CN@%KB_2JCS.png" style="zoom:60%;" />

末位商为0，此时的余数是错误的。此时通过恢复余数码来得到正确的余数。



#### 2）补码除法

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220225180809.png" style="zoom:50%;" />

> 余数的校正规则：
>
> 1. 若商为正：余数与被除数异号，余数+除数
> 2. 若商为负：余数与被除数异号时，余数-除数



阵列除法器

电路规模庞大，但是规整。每一个单元电路都是一致的。

主要掌握CAS单元的含义。

较之乘法器会多一个恢复余数。



#### 3）一些问答

--------------------

> 问题1：
> 查阅相关的资料发现：第一步进行除法时，有的选择先左移再-|Y|
> 而有的直接就-|Y|。
> 结果1：造成计算结果不一样。（究竟哪种是对的呢？）

**这个问题属实是没有认真阅读书捏。**

**原码一位除中：开头是要先移位再减。**

**补码一位除中：第一步是判断是否异号，如果异号就$+[Y]_{补}$。相当于是从第二步才开始移位。**



> 问题2：
> 除法要除到哪一步后可以停止？
> 是否与除数的位数有关？还是与被除数有关？

**一般是根据其字长（小数点后面跟几位数字）判定。**

**对原码一位除：但是要是到该精度下算得余数是负数，就要再往下算一位，让余数变正，但是商的位数不变。**

**对补码一位除：老实说我还没太搞懂。相对而言规则还是比较复杂的。规则如上（懒得抄了）**

**好像后来又懂了一点？**



> 问题3：
> 究竟算这个除法，我是要得到结果，也就是商；还是得到余数呢？
> （有感于习题中只要求计算步骤）

**看题目要求、或者是听老师安排。**



#### 4）阵列除法器

**补码运算的进位**

无符号减法是利用加补实现。会存在一个问题：当减数$>$被减数 时没有进位、减数$<$被减数 时有进位。

存在的现象是：够减的时候有进位（说明找高位借了一位，与事实相悖）、不够减的时候没进位（说明没有找高位借位，或许可以叫进位，与事实相悖）

**可控加减单元CAS**

由异或电路和一位的全加器构成。

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220319135407.jpg" style="zoom:33%;" />

**无符号数阵列除法器**

主要利用加减交替除法运算完成。

对于纯小数要满足：X<Y（即除数小于被除数）







## ALU(算术逻辑运算单元)

### 单元电路

算术运算部件和逻辑运算部件是ALU的两个基本单元电路。

#### 1）寄存器

**8D锁存器**（以74LS273为例）

由8个D触发器集成构成。输入为$D_0$\~$D_7$，输出也为$D_0$~$D_7$。

但是该锁存器输出是二态的，没有第三态（即高阻态）。因此单独的锁存器只能作为输出接口，不能单独作为输入接口（否则会引起数据总线竞争）。

**带三态门输出的锁存器**（以74LS374为例）

它与273的区别在于它的输出是由8个三态门输出到芯片外部。（也就是有一个使能端）低电平控制。

既可以作为输出接口又可以作为输入接口使用。



#### 2）移位寄存器

在数电中我们学的是74LS196,这里介绍74LS198。

可以实现并行输入输出、串行输入并行输出、左移右移、移位以及循环移位。





### ALU  IC芯片

介绍中规模集成电路74181，四位算术逻辑单元电路。

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220319135414.jpg" style="zoom: 33%;" />



**级联**

也是一个在数电中学过的概念。

组内先行进位组间串行进位：

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220319135420.jpg" style="zoom:33%;" />

但是吧，芯片之间是行波进位，速度就比较慢。于是进行改进：并行（先行）进位链集成74182。

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220319135426.jpg" style="zoom:33%;" />





### 运算器的结构

**具有三种基本结构：单总线、双总线、三总线结构**。

<img src="C:\Users\林颐\Desktop\笔记\图片库\QQ图片20220319135430.jpg" style="zoom: 33%;" />

双总线结构的运算器：

GR需要同时和两根总线连接，是双端口的器件。



三总线结构运算器：

是三端口的器件。

展开加法运算，只需一步（一个周期内完成，时钟周期？）。



运算器内总线越多，完成运算的步数越少，速度越高，但同时内部结构也会越复杂。

同时需要强调的是：

> 1. 总线总是分时工作的、任何时刻只允许传送一个部件的信号。==多余一个器件会引起总线竞争==
> 2. 同一时刻功能部件一次只能做一件事。
> 3. 在双总线以及三总线结构的运算器中需要多端口器件。

其他总线的介绍：

计算机的系统总线主要包括：DB（双向数据总线）、AB（地址总线）、CB（控制总线）。

数据和地址分别通过DR（双向数据寄存器）和AR（地址寄存器）与系统总线相连接。

构成计算机的主存储器、接口、外设就连接在系统总线上。





#### 标志寄存器（状态运算器）

用以保存ALU操作结果的某些状态。在不同的CPU中标志不同。

**最基本的5中标志位**：

==ZF（Zero Flag）==：结果为0の标志。运算结果全为0，ZF置1；否则置1。

==CF（Carry Flag）==:反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位=1，否则其值为0。

==OF（Overflow Flag）==：只对带符号数运算才有意义。溢出：OF=1；否则=0.

==SF（Sign Flag）==：符号标志。运算结果为正数=0，负数=1.

==PF（Parity Flag）==：奇偶标志，反映运算结果中“1”个数的奇偶性。偶数=1，奇数=0。





## 浮点运算

首先要复习一下浮点数的定义以及规格化。

### 数据浮点表示

浮点数：小数点可以浮动的数。（比如用于科学计数法）

一般形式为：$F = M \times R^E$

M：尾数、可正可负

E：阶码、可正可负

R：基数（在计算机中可取2，4，8，16...）



**规格化浮点数**

==通常，浮点数采用规格化形式来表示==。

规格化：将位数的绝对值限定在一个规定的数值范围之内。*当基值为2时，规格化浮点数尾数的绝对值应在 $\frac {1} 2$~1  之间。*

要使尾数的绝对值在此范围内，通过改变小数点的位置（相应地改变阶码）即可做到。



通常会有两种错误：

1. 上溢：浮点数的阶码大于最大阶码。此时机器会停止运算，进行溢出中断处理。
2. 下溢：浮点数的阶码小于最小阶码。此时“溢出”的数绝对值很小。通常将尾数各位强制为 0 ，按机器零处理，机器继续运行。

==一旦浮点数的位数确定后，不同的阶码和尾数尾数划分 会直接影响浮点数的表示范围和精度。所以要合理分配阶码和尾数的尾数。==



**3）规格化**

在进行运算前和运算后，必须对其尾数规格化，使其成为规格化数。

当尾数不是规格化数使，就要通过修改阶码并同时左右移尾数使其变成规格化数。

==将非规格化数 转为 规格化数 的过程叫规格化。==



### 加减

如下四步走：

**①对阶**

只有在两者的阶码相同时才能进行尾数的加减运算。**其原则是小阶对大阶**。也就是将小阶码（更小的数字挪到大数字的小数点处）

不断地右移获得阶码+1。==但是会在对阶时丢失尾数的低位，造成的误差相对较小。==但要是大阶对小阶，就会就是尾数的高位，导致错误的结果。

**②尾数进行加减运算（直接相加或是加补）**



**③规格化**

在进行完计算后可能得到的是一个非规格化数。则需要进行规格化。

**（1）左规**   ←

尾数是：$00.0XX···X$  或是 $11.1XX···X$ 

左规时，尾数每左移一位，阶码减1，必须同时判断阶码是否减到比所能表示的阶码还小。

如果出现，阶码无法表示太小的阶码，就出现了下溢出。（下溢出发生可认为结果=0）

**（2）右规**   →

结果出现：$10.XXX···X$  或是 $ {0}1.XXX···X$ 

表示尾数出现溢出，但并不代表整个结果浮点数溢出。

出现上述情况，可将尾数右移最多一次，阶码+1。

可能会出现阶码超出能表示的最大范围，发生上溢出。



**④舍入处理**

在对阶以及规格化的时候，需要将尾数右移，右移会丢弃尾数的最低位，出现了舍入的问题。一般采用以下三种方法。

**（1）截断法**

将需要丢弃的尾数低位丢弃。

**（2）末位恒置1法**

无论尾数右移丢弃的是0还是1，此法需要保证保留的尾数的最低位永远为1.

**（3）0舍1入法**

当尾数右移丢弃的是1，要保留的最末位+1，当丢弃0，保留的最末位不变。

（*但是可能遇到01.1111111时发生溢出，因此需要使用截尾法。*）



### 乘除

浮点相乘之积：其阶码=两乘数阶码之和、其尾数=两乘数尾数之积

要求(除法同乘法)：

> 1. 两浮点数一定是规格化数，且不为0。只要有一个乘数为0，乘积=0。
>
> 2. 阶码是两阶码之和，但是**还要判定是否会溢出**。
>
>    如果发生上溢出，那么乘积无法表示；下溢处，乘积用0表示。
>
> 3. 规格化尾数
>
>    因为两乘数的尾数均为规格化数，两者之积的绝对值肯定不会$\lt \frac{1}4$，也不会 > 1。
>
>    左规：最多只需要一次左移；
>
>    右规：最多只需要一次右移。



### 实现

**软件方法**：编写程序

**配专用浮点处理器**：在没有浮点处理能力的处理器之外，可以另外配上浮点处理器。

**在处理器中设置浮点运算部件**：浮点运算速度比软件实现快。

